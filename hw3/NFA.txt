NFA的实现要比DFA复杂一些，不过我们可以参照书上NFA的判断方法，套用到程序上。首先，我们设置一个当前
状态的集合（这和DFA不同，因为NFA有空串转移，当前状态可能不唯一），初始化为状态0，然后每次在从字符
串中读取字符前，都要先求当前状态的e-closure，遍历当前状态集合中每一个状态，计算出其在接受空串后能
够到达的状态，将其加入当前状态集合中（这个新加入的状态也要计算e-closure，一直重复，直到当前状态集
合无法出现新的状态），然后去掉当前状态集合中重复的元素，接下来就可以仿照DFA，从字符串中获取当前字
符，计算出当前状态集合中每一个状态在接受了这个字符后的状态（可能不止一个），全部加入到当前状态集合
中，然后把这个状态从状态集合中移除，最后我们将当前状态集合中重复的状态去掉，这样我们就完成了一次读
入一个字符并且转移的行为。一直这样循环下去，直到读取到字符串尾部，最后我们对当前状态集合求一次e-closure
闭包，然后将闭包中每一个状态和接受状态集合中的每一个状态进行匹配，如果一旦有一对匹配成功，返回YES，
否则返回NO。